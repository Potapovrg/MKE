Конфигурация малинки на примере python:
https://microtechnics.ru/raspberry-pi-obmen-dannymi-po-interfejsu-spi/

SPI0_MOSI - master output slave input - для передачи данных от ведущего к подчиненному
SPI0_MISO - master input slave output - для приема данных от slave
SPI0_SCLK - тактовый сигнал - его также генерирует master
СS1..10 - 10 любых свободных GPIO, 1 - передаем данные на устройсво 

Параметры SPI:

bits_per_word: 8

no_cs: True (CS программно на 10 устройств)

max_speed_hz: 375000 (В ходе тестов будем повышать)

mode: 0b00

Протокол:

Выставляем 1 на соотвествующей нужному телефону ноге GPIO CS1..10
Отправляем последовательность бит со следующей структурой:




typedef struct
{
	uint8_t target;
	uint8_t button;
	int8_t mouse_x;
	int8_t mouse_y;
	int8_t wheel;
	uint8_t modifier;
	uint8_t reserved;
	uint8_t keycode1;
	uint8_t keycode2;
	uint8_t keycode3;
	uint8_t keycode4;
	uint8_t keycode5;
	uint8_t keycode6;
} bufferSPI;

uint8_t target - Выставляем 1 в том бите, чем хотим упралять

     Byte | D7      D6      D5      D4      D3      D2      D1      D0
    ------+---------------------------------------------------------------------
      0   | 0       0       0       0      Check   Switch  Keyboard   Mouse
	  
	D2 = 1 режим OTG
	D2 = 0 режим ADB
	
	Check
	D3 = 1 устройство возвращает 1 байт со структурой как у target
	
	D0=1 если данные по USB отправлены в мышку
	D1=1 если данные по USB отправлены в клаву
	D2 = 1 режим OTG включен

uint8_t button - Аналогично, управление кнопками мыши

    Byte | D7      D6      D5      D4      D3      D2      D1      D0
   ------+---------------------------------------------------------------------
     0   |  0       0       0    Forward  Back    Middle  Right   Left (Button)

int8_t mouse_x; Перемещение курсора по x 
int8_t mouse_y; Перемещение курсора по y

uint8_t modifier; см. KEYBOARD_HELPER.pdf
uint8_t reserved;
uint8_t keycode1;
uint8_t keycode2;
uint8_t keycode3;
uint8_t keycode4;
uint8_t keycode5;
uint8_t keycode6;




Пример:
bufferSPI testbuf[6]={
		{0b00000000,0b00000000,0,0,0,0b00000000,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
		
		//0b00000000 - переключаемся в режим OTG
		
		{0b00000011,0b00000000,50,0,0,0b00100000,0x00,0x10,0x0E,0x08,0x28,0x00,0x00},
		
		//0b00000011 - управляем мышка + клава
		//0b00000000 - клавиши на мышке не нажаты
		//50 - перемещаем курсор на 50 пикс. по х
		//0 - по y стоим
		//0 - по колесику тоже
		//0b00100000 - нажат правый shift
		//0x00 - служебный байт, не трогаем
		//0x10 - m
		//0x0E - k
		//0x08 - e
		//0x28 - enter 
		
		{0b00000011,0b00000000,0,-50,0,0b00000000,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
		
		//отпускаем все клавиши
		
		{0b00000011,0b00000000,-50,0,0,0b00000000,0x00,0x10,0x0E,0x08,0x28,0x00,0x00},
		{0b00000011,0b00000000,0,50,0,0b00000000,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
		{0b00000100,0b00000000,0,0,0,0b00000000,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
		
		//0b00000100 - переключаемся в режим ADB, после этого отправлять команды в мышку/клавиатуру бесполезно - телефон переключился на комп
		
					};
					


{   
HAL_SPI_Transmit(&hspi1,&testbuf[1],sizeof(testbuf[1]),10); Отправляем содержмое буфера через SPI
HAL_Delay(1000); //Даем время на подключение OTG
	for (uint8_t i=1;i<5;i++)
	{
		HAL_SPI_Transmit(&hspi1,&testbuf[i],sizeof(testbuf[i]),10);
		HAL_Delay(50); 
	}
}

На выходе получаем:

MKE
mke

Перемещение мышки по квадрату 50х50

 
