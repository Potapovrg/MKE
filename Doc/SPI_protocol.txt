Конфигурация малинки на примере python:
https://microtechnics.ru/raspberry-pi-obmen-dannymi-po-interfejsu-spi/

SPI0_MOSI - master output slave input - для передачи данных от ведущего к подчиненному
SPI0_MISO - master input slave output - для приема данных от slave
SPI0_SCLK - тактовый сигнал - его также генерирует master
СS1..10 - 10 любых свободных GPIO, 1 - передаем данные на устройсво 

Параметры SPI:

bits_per_word: 8

no_cs: True (CS программно на 10 устройств)

max_speed_hz: 187500 (В ходе тестов будем повышать)

mode: 0b00

Протокол:

Выставляем 1 на соотвествующей нужному телефону ноге GPIO CS1..10
Отправляем последовательность бит со следующей структурой:




typedef struct
{
	uint8_t target;
	uint8_t button; //mouse
	int8_t mouse_x;
	int8_t mouse_y;
	int8_t wheel;
	uint8_t modifier; //keyboard
	uint8_t reserved;
	uint8_t keycode1;
	uint8_t keycode2;
	uint8_t keycode3;
	uint8_t keycode4;
	uint8_t keycode5;
	uint8_t keycode6;
	uint8_t c_keycode1; //consumer
	uint8_t c_keycode2;
	uint8_t c_keycode3;
	uint8_t c_keycode4;
	uint8_t crc
} bufferSPI;

uint8_t target - Выставляем 1 в том бите, чем хотим упралять

     Byte | D7      D6      D5      D4      D3      D2      D1      D0
    ------+---------------------------------------------------------------------
      0   | 0      Reset   Check    ADB     OTG   Consumer  Keyboard   Mouse
	  
	
	D0 = 1 отправить данные по USB в мышку //Перед отправкой Check пауза >2мс при частоте 187500
	D1 = 1 отправить данные по USB в клаву //Перед отправкой Check пауза >2мс при частоте 187500
	D2 = 1	отправить данные по USB в consumer (нажатие аппаратных клавиш) см. Consumer_key_codes.txt
	D3 = 1 включить режим OTG //Перед отправкой Check пауза 50мс на переключение режима
	D4 = 1 Включить режим ADB //Перед отправкой Check пауза 50мс на переключение режима
	D5 = 1 Check Проверить выполнене предыдущей команды 
	D6 = 1 Перезагрузить устройство
	
Приоритет у старших битов, т.е. если отправили противоречивую команду например перейти в режим OTG и Reset будет произведена перезагрузка.

------------------------------------------------------------------------------------------------------------------------------------------
Ответы на Check

Ответ: 
Первый байт -  Target где в каждом соотвествующем бите ставится 1, если команда была успешно выполнена
Второй байт - Контрольная сумма

Если отправить два Check подряд, то на второй ответом будет текущее сосостояние переключателя ADB/OTG в target

Коды ошибок:
0xF0 - Ошибка приема по SPI
0xF1 - Ошибка контрольной суммы

Возможный алгоритм действий, если поймали ошибку в момент передачи данных по USB:
Отправляем нули в мышку/клавиатуру чтобы исключить залипание клавиш, дожидаемся Check OK, продолжаем сценарий

Алгоритм действий, если поймали ошибку в момент переключения ADB/OTG:
Останавливаем передачу данных в другие устройсва. Ждем 50мс, повторяем Отправку команды на переключение, ждем 50мс отправляем Check, повторяем несколько раз пока не получим Check OK

SPI перезагружается при получении 2 неккоректных посылок - при необходимости можно изменить количество
---------------------------------------------------------------------------------------------------------------------------------------------

uint8_t button - Аналогично, управление кнопками мыши

    Byte | D7      D6      D5      D4      D3      D2      D1      D0
   ------+---------------------------------------------------------------------
     0   |  0       0       0    Forward  Back    Middle  Right   Left (Button)

int8_t mouse_x; Перемещение курсора по x 
int8_t mouse_y; Перемещение курсора по y

uint8_t modifier; см. KEYBOARD_HELPER.pdf
uint8_t reserved;
uint8_t keycode1;
uint8_t keycode2;
uint8_t keycode3;
uint8_t keycode4;
uint8_t keycode5;
uint8_t keycode6;


 
